{"code":"// createRender\nimport { ShapeFlags } from \"@vueshared\";\nimport { apiCreateApp } from \"./apiCreateApp\";\nimport { createComponentInstance, setupComponent } from \"./component\";\nimport { effect } from \"@vue/reactivity\";\nimport { CVnode, TEXT } from \"./vnode\";\nexport function createRender(renderOptionDom) {\n    // 获取全部的操作dom的方法\n    const { insert: hostInsert, remove: hostRemove, patchProps: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setElementText: hostSetElementText, setText: hostSetText } = renderOptionDom;\n    // 创建一个effect 让这个render执行\n    function setupRenderEffect(instance, container) {\n        // 需要创建一个 effect 在 effect 中调用 render 方法，\n        // 这样 render 方法中拿到的数据会收集这个 effect\n        // 属性改变了 会重新执行 effect\n        effect(function componentEffect() {\n            // 判断是否挂载\n            if (!instance.isMounted) {\n                // 获取到render  返回值\n                let proxy = instance.proxy;\n                let subTree = instance.subTree = instance.render.call(proxy, proxy);\n                console.log(\"subTree\", subTree);\n                // 组件渲染的节点 =》真实dom、\n                // 渲染子树 创建元素\n                patch(null, subTree, container);\n                instance.isMounted = true;\n            }\n            else {\n                // 更新逻辑\n                console.log(\"更新逻辑\");\n                // 对比新 旧\n                let proxy = instance.proxy;\n                let preTree = instance.subTree;\n                let nextTree = instance.render.call(proxy, proxy);\n                instance.subTree = nextTree;\n                patch(preTree, nextTree, container); // 更新 1、 旧的元素 2、新的虚拟dom\n            }\n        });\n    }\n    const mountComponent = (InitialVnode, container) => {\n        // 组件的渲染流程  核心\n        // 1、创建一个组建的实例\n        const instance = (InitialVnode.component =\n            createComponentInstance(InitialVnode));\n        // 2、解析数据到这个实例对象上\n        setupComponent(instance);\n        // 3 、创建一个effect 让这个render执行\n        setupRenderEffect(instance, container);\n    };\n    // 组件的创建\n    const processComponent = (n1, n2, container) => {\n        if (n1 == null) {\n            // 第一次挂载时\n            // 组件的挂载\n            mountComponent(n2, container);\n        }\n        else {\n            // 组件的更新\n            // updateComponent(n1, n2, container);\n        }\n    };\n    // -----------------------处理文本-----------------------\n    const processText = (n1, n2, container) => {\n        if (n1 == null) {\n            // 初始化\n            // 创建文本 渲染到页面中\n            hostInsert(hostCreateText(n2.children), container);\n        }\n        else {\n            // 更新\n            // patchText(n1, n2);\n        }\n    };\n    // -----------------------处理元素-----------------------\n    const mountChildren = (children, container) => {\n        for (let i = 0; i < children.length; i++) {\n            let child = CVnode(children[i]);\n            patch(null, child, container);\n        }\n    };\n    const isSameVnodeType = (n1, n2) => {\n        return n1.type === n2.type && n1.key === n2.key;\n    };\n    const unmount = (vnode) => {\n        // 删除元素\n        hostRemove(vnode.el);\n    };\n    const patch = (n1, n2, container) => {\n        // 针对不同的类型 1 组件  2  元素 3 文本\n        // 比对  vue2中 1：判断是不是同一个元素 \n        // 2: 是同一个元素的话，比对属性，递归比对儿子\n        // 判断是不是同一个元素\n        if (n1 && !isSameVnodeType(n1, n2)) {\n            // 删除老的元素\n            unmount(n1);\n        }\n        let { shapeFlag, type } = n2;\n        console.log(\"type\", type);\n        switch (type) {\n            case TEXT:\n                processText(n1, n2, container);\n                break;\n            default:\n                if (shapeFlag & ShapeFlags.ELEMENT) {\n                    // 处理元素 =》 创建元素\n                    processElement(n1, n2, container);\n                }\n                else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n                    processComponent(n1, n2, container);\n                }\n        }\n    };\n    const processElement = (n1, n2, container) => {\n        if (n1 == null) {\n            // 初始化\n            mountElement(n2, container);\n        }\n        else {\n            // 更新\n            // patchElement(n1, n2, container);\n        }\n    };\n    const mountElement = (vnode, container) => {\n        // 递归 渲染 h('div',{},h('span',{},'hello')) => dom操作 =》放到对应的页面中\n        let { type, props, shapeFlag, children } = vnode;\n        // 创建元素\n        let el = hostCreateElement(type);\n        // 添加属性\n        if (props) {\n            for (let key in props) {\n                hostPatchProp(el, key, null, props[key]);\n            }\n        }\n        // 处理儿子\n        // h('div, {style:{color:'red'}},'text')  //儿子是文本\n        // h('div, {style:{color:'red'}},['text1','text2'])   //儿子是数组\n        // h('div, {style:{color:'red'}},h('span',{},'hello')) // 儿子是元素\n        if (children) {\n            if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n                console.log(\"children-走到这里了吗\");\n                hostSetElementText(el, children);\n            }\n            else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n                mountChildren(children, el);\n            }\n            // 放到对应的位置\n            hostInsert(el, container);\n        }\n    };\n    let render = (vnode, container) => {\n        console.log(\"render~11111111~~\", vnode);\n        // 这里就得到了虚拟dom ， 然后将虚拟dom转换成真实dom\n        // 渲染  第一次\n        patch(null, vnode, container); // 第一个参数 旧节点 第二个参数 新节点  第三个参数 位置\n    };\n    return {\n        // 创建vNode\n        createApp: apiCreateApp(render),\n    };\n    // 给组件 创建一个instance 添加相关信息\n    // 处理 setup  中 context 四个参数\n    // 通过代理 方便 proxy 取值\n    // render (1) setup 返回值是一个函数  就是 render\n    // 如果 setup 返回值是一个函数 就执行  源码中  就 是通过一个判断 来解决\n    // 如果 setup 返回值是一个对象 就是值\n}\n","references":["E:/前端学习/vue-source/hand-write-vue3-source/packages/shared/src/index.ts","E:/前端学习/vue-source/hand-write-vue3-source/packages/runtime-core/src/apiCreateApp.ts","E:/前端学习/vue-source/hand-write-vue3-source/packages/runtime-core/src/component.ts","E:/前端学习/vue-source/hand-write-vue3-source/packages/reactivity/src/index.ts","E:/前端学习/vue-source/hand-write-vue3-source/packages/runtime-core/src/vnode.ts"],"dts":{"name":"E:/前端学习/vue-source/hand-write-vue3-source/node_modules/.cache/rollup-plugin-typescript2/placeholder/runtime-core/src/render.d.ts","writeByteOrderMark":false,"text":"export declare function createRender(renderOptionDom: any): {\n    createApp: (rootComponent: any, rootProps: any) => {\n        _component: any;\n        _props: any;\n        _container: any;\n        mount(rootContainer: any): void;\n    };\n};\n"}}
