{"code":"// 定义了 effect 函数，用于创建一个响应式的副作用函数\n// effect 函数接收两个参数，第一个参数是一个函数，第二个参数是一个配置对象\n// effect 函数返回一个函数，这个函数就是响应式的副作用函数\nimport { isArray, isIntegerKey } from \"@vue/shared\";\nexport function effect(fn, options = {}) {\n    if (fn.effect) {\n        fn = fn.effect;\n    }\n    const effect = createReactiveEffect(fn, options);\n    if (!options.lazy) {\n        effect();\n    }\n    return effect;\n}\nlet uid = 0;\nlet activeEffect; // 用于保存当前的effect\nconst effectStack = []; // 存储effect的栈\nfunction createReactiveEffect(fn, options) {\n    //返回一个函数\n    const effect = function reactiveEffect() {\n        // 执行\n        // 判断effect是否在effectStack中 如果不在则执行 /\n        // 这里的意思 就是 如果重新执行了effect，不会再次添加到effectStack中\n        if (!effectStack.includes(effect)) {\n            try {\n                // 入栈\n                effectStack.push(effect);\n                activeEffect = effect;\n                return fn();\n            }\n            finally {\n                effectStack.pop();\n                activeEffect = effectStack[effectStack.length - 1];\n            }\n        }\n    };\n    // 为effect添加属性 effect是函数对象 可以添加属性\n    effect.id = uid++; // 唯一标识区别effect\n    effect._isEffect = true; // 标识是一个effect，区分effect是不是响应式\n    effect.raw = fn; // 保存原函数\n    effect.options = options; // 报存用户传入的配置\n    return effect;\n}\n// 收集effect依赖, 在获取数据的时候触发get  手机effect\nlet targetMap = new WeakMap();\nexport function Track(target, type, key) {\n    console.log(\"收集依赖\", target, type, key, activeEffect);\n    // 对应的effect\n    // key 和我们的effect 一一对应 map=> key = target => 属性 => [effect] set\n    if (activeEffect === undefined) {\n        // 没有effect依赖\n        return;\n    }\n    // 获取effect  {target:{key:(name)}}\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map()));\n    }\n    // 获取key对应的effect\n    let dep = depsMap.get(key);\n    if (!dep) {\n        depsMap.set(key, (dep = new Set()));\n    }\n    // 如果没有收集过依赖\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect);\n    }\n    console.log(\"targetMap\", targetMap);\n}\n// 问题  effect 会有嵌套的问题存在\n// effect(() => {\n//   state.name = 'lisi'\n//   state.age = 20\n//    effect(() => {\n//       state.name = 'lisi'\n//         state.age = 20\n//      }\n// })\n// 触发更新\n//1、处理对象\nexport function trigger(target, type, key, newValue, oldValue) {\n    console.log(\"触发更新\", target, type, key, newValue, oldValue);\n    // 获取对应的effect\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        return;\n    }\n    // 有目标对象\n    let effectSet = new Set(); // 如果有多个同时修改一个值，set过滤掉重复的effect\n    const add = (effectsAdd) => {\n        if (effectsAdd) {\n            effectsAdd.forEach((effect) => {\n                effectSet.add(effect);\n            });\n        }\n    };\n    add(depsMap.get(key));\n    // 处理数组 就是  key = length\n    if (key === \"length\" && isArray(target)) {\n        depsMap.forEach((dep, key) => {\n            // 如果改变的是数组长度，那么length也要触发更新\n            if (key === \"length\" || key >= newValue) {\n                add(dep);\n            }\n        });\n    }\n    else {\n        // 对象\n        if (key !== undefined) {\n            add(depsMap.get(key));\n        }\n        // 数组  使用 索引进行修改\n        switch (type) {\n            case 1 /* TrackOpTypes.ADD */:\n                if (isArray(target) && isIntegerKey(key)) {\n                    add(depsMap.get(\"length\"));\n                }\n        }\n    }\n    // 执行effectSet\n    effectSet.forEach((effect) => {\n        effect();\n    });\n}\n","references":["D:/个人项目/vue-source/packages/shared/src/index.ts","D:/个人项目/vue-source/packages/reactivity/src/operations.ts"],"dts":{"name":"D:/个人项目/vue-source/node_modules/.cache/rollup-plugin-typescript2/placeholder/reactivity/src/effect.d.ts","writeByteOrderMark":false,"text":"export declare function effect(fn: any, options?: any): {\n    (): any;\n    id: number;\n    _isEffect: boolean;\n    raw: any;\n    options: any;\n};\nexport declare function Track(target: any, type: any, key: any): void;\nexport declare function trigger(target: any, type: any, key: any, newValue?: any, oldValue?: any): void;\n"}}
